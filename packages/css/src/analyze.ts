import postcss, { type ChildNode } from 'postcss';

type Report = {
  total: number;
  hasDataAttribute: number;
  hasNestedSelector: number;
  // Note: Sum of Object.values(dataAttributes) can be greater
  // than hasDataAttribute, if more than one data attribute is
  // used within the same selector. In this case, hasDataAttribute
  // is incremented by 1, but several values within dataAttributes
  // might be incremented at once.
  dataAttributes: DataAttributeBreakdown;
  nestedSelectors: NestedSelectorBreakdown;
  hasInlineImage: number;
  hasVariable: number;
};

export type DataAttributeBreakdown = { [key: string]: number };

// Breakdown of the number of simple/compound selectors found in
// each complex selector.
//
// See https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors
export type NestedSelectorBreakdown = { [key: number]: number };

/**
 * Analyze the quality of stylesheet generated by Compiled
 * @param stylesheet css content i.e. `.aaaabbbb{font-size: 10px}`
 * @param cssVariableFilter exclude CSS variables in the format `var(--${cssVariableFilter}, ...)` from the output report
 * @returns Report
 */
export const analyze = (stylesheet: string, cssVariableFilter?: string): Report => {
  const report: Report = {
    total: 0,
    hasDataAttribute: 0,
    hasNestedSelector: 0,
    dataAttributes: {},
    nestedSelectors: {},
    hasInlineImage: 0,
    hasVariable: 0,
  };

  function checkHasDataAttribute(selectorList: string[]) {
    const DATA_ATTRIBUTE_REGEX = /(?<=\[data-)[^\]]+(?=\])/gi;

    for (const selector of selectorList) {
      const matches = selector.match(DATA_ATTRIBUTE_REGEX);
      if (!matches) continue;
      report.hasDataAttribute++;

      const uniqueAttributeNames = [...new Set(matches.map((s) => s.split('=')[0]))];
      for (const attributeName of uniqueAttributeNames) {
        report.dataAttributes[attributeName] = (report.dataAttributes[attributeName] || 0) + 1;
      }
    }
  }

  function checkHasNestedSelector(selectorList: string[]) {
    // This regex should match once for each combinator present in a
    // complex selector. A combinator can be a space, ">", "~", "+", "||".
    //
    // Spaces that are not between two selectors are ignored (via the use of
    // a lookbehind and lookahead). For example, ".a, b, c" will not result in matches because of the comma in between.
    //
    // For example, this should match four times:
    //     ._d6tl12gs > div > div ~ span h2 { ... }
    //
    // The above example contains two ">" matches, one "~" match, and a " "
    // match between "span" and "h2".
    const COMBINATOR_REGEX = /(?<=[a-z1-9\[\]\(\)\*]) ?(>| |\+|~|(\|\|)) ?(?!({|,))/gi;

    for (const selector of selectorList) {
      const matches = selector.match(COMBINATOR_REGEX);
      if (matches) {
        report.hasNestedSelector++;

        const numberOfLayers = matches.length + 1;
        report.nestedSelectors[numberOfLayers] = (report.nestedSelectors[numberOfLayers] || 0) + 1;
      }
    }
  }

  function checkHasVariable(value: string) {
    if (value.includes('var(')) {
      if (!cssVariableFilter || !value.includes(`var(--${cssVariableFilter}`)) {
        report.hasVariable++;
      }
    }
  }

  function checkHasInlineImage(value: string) {
    if (value.includes('url(data:image')) {
      report.hasInlineImage++;
    }
  }

  function check(node: ChildNode) {
    if (node.type !== 'rule') return;
    report.total++;

    const selectorList = node.selector.split(',').map((s) => s.trim());

    checkHasDataAttribute(selectorList);
    checkHasNestedSelector(selectorList);

    // We assume it has one and only one declaration, because the input is an atomic stylesheet.
    // (One case where this assumption doesn't hold is vendor prefixes e.g. a ruleset can have both "max-width: -moz-fit-content" and "max-width: fit-content", but we ignore this.)
    if (node.nodes[0]?.type !== 'decl') return;
    const value = node.nodes[0].value;

    checkHasVariable(value);
    checkHasInlineImage(value);
  }

  const result = postcss([
    {
      postcssPlugin: 'atomicify-rules',
      OnceExit(root) {
        root.each((node) => {
          if (node.type === 'rule') {
            check(node);
          }
          // ignore keyframes
          if (node.type === 'atrule' && node.name === 'keyframes') return;

          // if other atrules (media query, container, support, etc), check its children
          if (node.type === 'atrule') {
            node.nodes.forEach((childNode) => check(childNode));
          }
        });
      },
    },
  ]).process(stylesheet, { from: undefined });

  // We need to access something to make the transformation happen.
  result.css;

  return report;
};
