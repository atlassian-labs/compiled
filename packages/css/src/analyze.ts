import postcss, { type ChildNode } from 'postcss';

type Report = {
  total: number;
  hasNestedSelector: number;
  hasInlineImage: number;
  hasVariable: number;
};

/**
 * Analyze the quality of stylesheet generated by Compiled
 * @param stylesheet css content i.e. `.aaaabbbb{font-size: 10px}`
 * @returns Report
 */
export const analyze = (stylesheet: string): Report => {
  const report: Report = {
    total: 0,
    hasNestedSelector: 0,
    hasInlineImage: 0,
    hasVariable: 0,
  };

  function check(node: ChildNode) {
    if (node.type !== 'rule') return;
    report.total++;

    // we assume the selector has a nested selector if
    // has space e.g. `.foo .bar`
    // has '>' e.g. `.foo>.bar`
    if (node.selector.includes(' ') || node.selector.includes('>')) {
      report.hasNestedSelector++;
    }

    // we assume it has one and only one declaration, because the input is Atomic stylesheet.
    if (node.nodes[0]?.type !== 'decl') return;
    const value = node.nodes[0].value;
    if (value.includes('var(')) {
      report.hasVariable++;
    }

    if (value.includes('url(data:image')) {
      report.hasInlineImage++;
    }
  }

  const result = postcss([
    {
      postcssPlugin: 'atomicify-rules',
      OnceExit(root) {
        root.each((node) => {
          if (node.type === 'rule') {
            check(node);
          }
          // ignore keyframes
          if (node.type === 'atrule' && node.name === 'keyframes') return;

          // if other atrules (media query, container, support, etc), check its children
          if (node.type === 'atrule') {
            node.nodes.forEach((childNode) => check(childNode));
          }
        });
      },
    },
  ]).process(stylesheet, { from: undefined });

  // We need to access something to make the transformation happen.
  result.css;

  return report;
};
