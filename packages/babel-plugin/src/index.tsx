import { declare } from '@babel/helper-plugin-utils';
import template from '@babel/template';
import * as t from '@babel/types';
import jsxSyntax from '@babel/plugin-syntax-jsx';
import { NodePath } from '@babel/traverse';
import * as path from 'path';
import { importSpecifier } from './utils/ast-builders';
import { Cache } from './utils/cache';
import { visitCssPropPath } from './css-prop';
import { visitStyledPath } from './styled';
import { visitClassNamesPath } from './class-names';
import { State } from './types';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const pkgJson = require('../package.json');

const cache = new Cache();

const parseFilename = (filename: string | undefined) => {
  if (!filename) {
    return 'File';
  }
  return path.basename(filename);
};

/**
 * Appends runtime import to code. If it is already present, it will append import specifiers
 * to already imported declaration path else it will create fresh import declaration path
 * with runtime import specifiers.
 *
 * @param path ImportDeclaration node path
 */
const appendRuntimeImports = (path: NodePath<t.ImportDeclaration>) => {
  const runtimeImportNames = ['ax', 'ix', 'CC', 'CS'];
  const runtimeImportModuleName = '@compiled/react/runtime';

  // Check if we have any sibling runtime import
  const runtimeImportFound = path
    .getAllPrevSiblings()
    .concat(path.getAllNextSiblings())
    .find(
      (path) =>
        t.isImportDeclaration(path.node) && path.node.source.value === runtimeImportModuleName
    ) as NodePath<t.ImportDeclaration> | undefined;

  if (runtimeImportFound) {
    /**
     * Get local import name instead of imported name to handle scenario when
     * import specifier is imported as named and normal both.
     *
     * eg. import { CC as CompiledRoot, ax, CC, CS } from '@compiled/react/runtime';
     * In above example `CC` is used both as `CompiledRoot` and `CC`.
     */
    const localImportNames = runtimeImportFound
      .get('specifiers')
      .map((specifier) => specifier.node.local.name);

    runtimeImportNames.forEach((runtimeImportName) => {
      // Avoids duplicate imports from being appended if already present
      if (!localImportNames.includes(runtimeImportName)) {
        runtimeImportFound.pushContainer('specifiers', importSpecifier(runtimeImportName));
      }
    });
  } else {
    // Add the runtime entrypoint module
    path.insertBefore(
      t.importDeclaration(
        runtimeImportNames.map((runtimeImportName) => importSpecifier(runtimeImportName)),
        t.stringLiteral(runtimeImportModuleName)
      )
    );
  }
};

export default declare<State>((api) => {
  api.assertVersion(7);

  return {
    name: pkgJson.name,
    inherits: jsxSyntax,
    pre() {
      this.sheets = {};
      cache.initialize(this.opts);
      this.cache = cache;
    },
    visitor: {
      Program: {
        exit(path, state) {
          if (!state.compiledImports) {
            return;
          }

          const {
            opts: { importReact: shouldImportReact = true },
          } = state;

          if (shouldImportReact && !path.scope.getBinding('React')) {
            // React is missing - add it in at the last moment!
            path.unshiftContainer('body', template.ast(`import * as React from 'react'`));
          }

          if (state.compiledImports.styled && !path.scope.getBinding('forwardRef')) {
            // forwardRef is missing - add it in at the last moment!
            path.unshiftContainer('body', template.ast(`import { forwardRef } from 'react'`));
          }

          const version = process.env.TEST_PKG_VERSION || pkgJson.version;

          path.addComment(
            'leading',
            ` ${parseFilename(state.filename)} generated by ${pkgJson.name} v${version} `
          );

          // Add a line break the comment
          path.unshiftContainer('body', t.noop());
        },
      },
      ImportDeclaration(path, state) {
        if (path.node.source.value !== '@compiled/react') {
          return;
        }

        // The presence of the module enables CSS prop
        state.compiledImports = {};

        // Go through each import and enable each found API
        path.get('specifiers').forEach((specifier) => {
          if (!state.compiledImports || !specifier.isImportSpecifier()) {
            // Bail out early
            return;
          }

          (['styled', 'ClassNames'] as const).forEach((apiName) => {
            if (
              state.compiledImports &&
              t.isIdentifier(specifier.node?.imported) &&
              specifier.node?.imported.name === apiName
            ) {
              // Enable the API with the local name
              state.compiledImports[apiName] = specifier.node.local.name;

              // Remove specifier
              specifier.remove();
            }
          });
        });

        appendRuntimeImports(path);

        if (path.node.specifiers.length === 0) {
          // No more imports - remove the whole lot!
          path.remove();
        }
      },
      TaggedTemplateExpression(path, state) {
        if (!state.compiledImports?.styled) {
          return;
        }

        visitStyledPath(path, { state, parentPath: path });
      },
      CallExpression(path, state) {
        if (!state.compiledImports) {
          return;
        }

        visitStyledPath(path, { state, parentPath: path });
      },
      JSXElement(path, state) {
        if (!state.compiledImports?.ClassNames) {
          return;
        }

        visitClassNamesPath(path, { state, parentPath: path });
      },
      JSXOpeningElement(path, state) {
        if (!state.compiledImports) {
          return;
        }

        visitCssPropPath(path, { state, parentPath: path });
      },
    },
  };
});
