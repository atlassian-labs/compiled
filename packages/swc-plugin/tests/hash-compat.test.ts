// @ts-nocheck
import * as babel from '@babel/core';

import compiledBabelPlugin from '../../babel-plugin/src/babel-plugin';

import { transformResultString } from './swc-output';

async function babelTransform(
  code: string,
  pluginOptions: Record<string, unknown> = { optimizeCss: false }
) {
  const result = await babel.transformAsync(code, {
    filename: 'test.tsx',
    babelrc: false,
    configFile: false,
    parserOpts: { plugins: ['jsx', 'typescript'] as any },
    plugins: [
      [compiledBabelPlugin as any, { importSources: ['@compiled/react'], ...pluginOptions }],
    ],
    compact: true,
    retainLines: false,
  });
  return result?.code || '';
}

function extractHashes(output: string) {
  const classSet = new Set<string>();

  // From emitted CSS strings
  for (const m of output.matchAll(/\._([a-z0-9][a-z0-9_-]*)\{/g)) {
    classSet.add(`_${m[1]}`);
  }

  // From string literals containing classes
  for (const m of output.matchAll(/"(_[a-z0-9][a-z0-9_-]*)"/g)) {
    classSet.add(m[1]);
  }

  // From concatenated class strings in arrays (e.g. "_a _b")
  for (const m of output.matchAll(/"([^"\n]*_[a-z0-9][a-z0-9_-]*(?:[^"\n]*))"/g)) {
    const tokens = m[1].split(/\s+/g);
    for (const t of tokens) {
      if (/^_[a-z0-9][a-z0-9_-]*$/.test(t)) classSet.add(t);
    }
  }

  const keyframeSet = new Set<string>();
  for (const m of output.matchAll(/@keyframes\s+(k[0-9a-z]+)/g)) keyframeSet.add(m[1]);
  for (const m of output.matchAll(/animation-name:([k0-9a-z]+)/g)) keyframeSet.add(m[1]);

  return { classes: Array.from(classSet).sort(), keyframes: Array.from(keyframeSet).sort() };
}

describe('hash compatibility between Babel and SWC', () => {
  it('css prop: simple usage', async () => {
    const code = `
      import '@compiled/react';
      const C = () => <div css={{ color: 'red', fontSize: 16 }} />;
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const _2="._1wybexct{font-size:16px}";const _="._syaz5scu{color:red}";const C=()=><CC>
        <CS>{[_,_2]}</CS>
        {<div className={ax(["_syaz5scu _1wybexct"])}/>}
      </CC>;"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "import { ax, ix } from "@compiled/react/runtime";
      const _2 = "._1wybexct{font-size:16px}";
      const _ = "._syaz5scu{color:red}";
      const C = ()=>/*#__PURE__*/ React.createElement("div", {
              className: ax([
                  "_syaz5scu",
                  "_1wybexct"
              ])
          });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('cssMap: declaration emits deterministic hashes', async () => {
    const code = `
      import { cssMap } from '@compiled/react';
      const styles = cssMap({ primary: { color: 'red' }, secondary: { color: 'blue' } });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(
      `"/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const styles={primary:"_syaz5scu",secondary:"_syaz13q2"};"`
    );
    expect(swcOut).toMatchInlineSnapshot(`
      "import { ax, ix } from "@compiled/react/runtime";
      const _2 = "._syaz13q2{color:blue}";
      const _ = "._syaz5scu{color:red}";
      const styles = {
          primary: "_syaz5scu",
          secondary: "_syaz13q2"
      };
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('keyframes: animation name hashing', async () => {
    const code = `
      import { css, keyframes } from '@compiled/react';
      const fadeOut = keyframes({ from: { opacity: 1 }, to: { opacity: 0 } });
      <div css={{ animationName: fadeOut }} />
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const _2="._j7hq1sbx{animation-name:k1m8j3od}";const _="@keyframes k1m8j3od{0%{opacity:1}to{opacity:0}}";const fadeOut=null;<CC>
        <CS>{[_,_2]}</CS>
        {<div className={ax(["_j7hq1sbx"])}/>}
      </CC>;"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "import { ax, ix } from "@compiled/react/runtime";
      const _2 = "._j7hq1sbx{animation-name:k1m8j3od}";
      const _ = "@keyframes k1m8j3od{0%{opacity:1}to{opacity:0}}";
      const fadeOut = null;
      /*#__PURE__*/ React.createElement("div", {
          className: ax([
              "_j7hq1sbx"
          ])
      });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('styled: object call expression', async () => {
    const code = `
      import { styled } from '@compiled/react';
      const C = styled.div({ color: 'red', ':hover': { color: 'blue' }, '@media screen': { fontSize: 16 } });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import{forwardRef}from'react';import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const _3="@media screen{._1yzyexct{font-size:16px}}";const _2="._30l313q2:hover{color:blue}";const _="._syaz5scu{color:red}";const C=forwardRef(({as:C="div",style:__cmpls,...__cmplp},__cmplr)=>{if(__cmplp.innerRef){throw new Error("Please use 'ref' instead of 'innerRef'.");}return<CC>
              <CS>{[_,_2,_3]}</CS>
              <C{...__cmplp}style={__cmpls}ref={__cmplr}className={ax(["_syaz5scu _30l313q2 _1yzyexct",__cmplp.className])}/>
            </CC>;});if(process.env.NODE_ENV!=='production'){C.displayName='C';}"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "import { forwardRef } from "react";
      import { ax, ix } from "@compiled/react/runtime";
      const _3 = "@media screen{._1yzyexct{font-size:16px}}";
      const _2 = "._30l313q2:hover{color:blue}";
      const _ = "._syaz5scu{color:red}";
      import { styled } from '@compiled/react';
      const C = /*#__PURE__*/ forwardRef(({ as: C = "div", style: __cmpls, ...__cmplp }, __cmplr)=>{
          if (__cmplp.innerRef) {
              throw new Error("Please use 'ref' instead of 'innerRef'.");
          }
          return /*#__PURE__*/ React.createElement(C, {
              className: ax([
                  "_syaz5scu",
                  "_30l313q2",
                  "_1yzyexct",
                  __cmplp.className
              ]),
              style: {
                  ...__cmpls
              },
              ref: __cmplr,
              ...__cmplp
          });
      });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('css: padding shorthand via css() outputs identical hashes', async () => {
    const code = `
      import { css } from '@compiled/react';
      const styles = css({ padding: '10px 20px' });
      <div css={styles} />
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const _4="._19bvgktf{padding-left:20px}";const _3="._n3td19bv{padding-bottom:10px}";const _2="._u5f3gktf{padding-right:20px}";const _="._ca0q19bv{padding-top:10px}";const styles=null;<CC>
        <CS>{[_,_2,_3,_4]}</CS>
        {<div className={ax(["_ca0q19bv _u5f3gktf _n3td19bv _19bvgktf"])}/>}
      </CC>;"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "import { ax, ix } from "@compiled/react/runtime";
      const _4 = "._19bvgktf{padding-left:20px}";
      const _3 = "._n3td19bv{padding-bottom:10px}";
      const _2 = "._u5f3gktf{padding-right:20px}";
      const _ = "._ca0q19bv{padding-top:10px}";
      const styles = null;
      /*#__PURE__*/ React.createElement("div", {
          className: ax([
              "_ca0q19bv",
              "_u5f3gktf",
              "_n3td19bv",
              "_19bvgktf"
          ])
      });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('styled: unicode content in pseudo element', async () => {
    const code = `
      import { styled } from '@compiled/react';
      const C = styled.div({ ':after': { content: 'ðŸ˜Ž' } });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import{forwardRef}from'react';import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const _="._aetrib82:after{content:\\"\\uD83D\\uDE0E\\"}";const C=forwardRef(({as:C="div",style:__cmpls,...__cmplp},__cmplr)=>{if(__cmplp.innerRef){throw new Error("Please use 'ref' instead of 'innerRef'.");}return<CC>
              <CS>{[_]}</CS>
              <C{...__cmplp}style={__cmpls}ref={__cmplr}className={ax(["_aetrib82",__cmplp.className])}/>
            </CC>;});if(process.env.NODE_ENV!=='production'){C.displayName='C';}"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "import { forwardRef } from "react";
      import { ax, ix } from "@compiled/react/runtime";
      const _ = '._aetrib82:after{content:"ðŸ˜Ž"}';
      import { styled } from '@compiled/react';
      const C = /*#__PURE__*/ forwardRef(({ as: C = "div", style: __cmpls, ...__cmplp }, __cmplr)=>{
          if (__cmplp.innerRef) {
              throw new Error("Please use 'ref' instead of 'innerRef'.");
          }
          return /*#__PURE__*/ React.createElement(C, {
              className: ax([
                  "_aetrib82",
                  __cmplp.className
              ]),
              style: {
                  ...__cmpls
              },
              ref: __cmplr,
              ...__cmplp
          });
      });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('cssMap: nested @media + :hover variant', async () => {
    const code = `
      import { cssMap } from '@compiled/react';
      const styles = cssMap({
        primary: {
          '@media screen and (min-width: 600px)': { ':hover': { color: 'red' } },
        },
      });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(
      `"/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const styles={primary:"_1hnx5scu"};"`
    );
    expect(swcOut).toMatchInlineSnapshot(`
      "import { ax, ix } from "@compiled/react/runtime";
      const _ = "@media screen and (min-width: 600px){._1hnx5scu:hover{color:red}}";
      const styles = {
          primary: "_1hnx5scu"
      };
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('css-prop: attribute selector without quotes', async () => {
    const code = `/** @jsxImportSource @compiled/react */
      const C = () => <div css={{ '[data-foo=bar]': { color: 'blue' } }} />;
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import{ax,ix,CC,CS}from"@compiled/react/runtime";const _="._1cjh13q2 [data-foo=bar]{color:blue}";const C=()=><CC>
        <CS>{[_]}</CS>
        {<div className={ax(["_1cjh13q2"])}/>}
      </CC>;"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "/** @jsxImportSource @compiled/react */ import { jsx as _jsx } from "@compiled/react/jsx-runtime";
      import { ax, ix } from "@compiled/react/runtime";
      const _ = "._1cjh13q2[data-foo=bar]{color:blue}";
      const C = ()=>/*#__PURE__*/ _jsx("div", {
              className: ax([
                  "_1cjh13q2"
              ])
          });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('styled: !important value hashing parity', async () => {
    const code = `
      import { styled } from '@compiled/react';
      const C = styled.div({ color: 'red !important' });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import{forwardRef}from'react';import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";const _="._syaz1qpq{color:red!important}";const C=forwardRef(({as:C="div",style:__cmpls,...__cmplp},__cmplr)=>{if(__cmplp.innerRef){throw new Error("Please use 'ref' instead of 'innerRef'.");}return<CC>
              <CS>{[_]}</CS>
              <C{...__cmplp}style={__cmpls}ref={__cmplr}className={ax(["_syaz1qpq",__cmplp.className])}/>
            </CC>;});if(process.env.NODE_ENV!=='production'){C.displayName='C';}"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "import { forwardRef } from "react";
      import { ax, ix } from "@compiled/react/runtime";
      const _ = "._syaz1qpq{color:red!important}";
      import { styled } from '@compiled/react';
      const C = /*#__PURE__*/ forwardRef(({ as: C = "div", style: __cmpls, ...__cmplp }, __cmplr)=>{
          if (__cmplp.innerRef) {
              throw new Error("Please use 'ref' instead of 'innerRef'.");
          }
          return /*#__PURE__*/ React.createElement(C, {
              className: ax([
                  "_syaz1qpq",
                  __cmplp.className
              ]),
              style: {
                  ...__cmpls
              },
              ref: __cmplr,
              ...__cmplp
          });
      });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('css-prop: :hover without ampersand normalizes to & :hover for hashing', async () => {
    const code = `/** @jsxImportSource @compiled/react */
      const C = () => <div css={{ ':hover': { color: 'blue' } }} />;
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(`
      "/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import{ax,ix,CC,CS}from"@compiled/react/runtime";const _="._30l313q2:hover{color:blue}";const C=()=><CC>
        <CS>{[_]}</CS>
        {<div className={ax(["_30l313q2"])}/>}
      </CC>;"
    `);
    expect(swcOut).toMatchInlineSnapshot(`
      "/** @jsxImportSource @compiled/react */ import { jsx as _jsx } from "@compiled/react/jsx-runtime";
      import { ax, ix } from "@compiled/react/runtime";
      const _ = "._30l313q2:hover{color:blue}";
      const C = ()=>/*#__PURE__*/ _jsx("div", {
              className: ax([
                  "_30l313q2"
              ])
          });
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('cssMap: nested @supports + @media + &:hover hashing parity', async () => {
    const code = `
      import { cssMap } from '@compiled/react';
      export const styles = cssMap({
        primary: {
          '@supports (display: grid)': {
            '@media': {
              'screen and (min-width: 600px)': { '&:hover': { color: 'red' } },
            },
          },
        },
      });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    expect(babelOut).toMatchInlineSnapshot(
      `"/* test.tsx generated by @compiled/babel-plugin v0.38.1 */import*as React from'react';import{ax,ix,CC,CS}from"@compiled/react/runtime";export const styles={primary:"_1xr05scu"};"`
    );
    expect(swcOut).toMatchInlineSnapshot(`
      "import { ax, ix } from "@compiled/react/runtime";
      const _ = "@supports (display: grid){@media}{._1xr05scuscreen and(min-width: 600px):hover{color:red}}";
      export const styles = {
          primary: "_1xr05scu"
      };
      "
    `);

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('cssMap: nested @container + &:hover hashing parity', async () => {
    const code = `
      import { cssMap } from '@compiled/react';
      export const styles = cssMap({
        primary: {
          '@container (width > 600px)': {
            '&:hover': { color: 'red' },
          },
        },
      });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('cssMap: nested @layer + &:hover hashing parity', async () => {
    const code = `
      import { cssMap } from '@compiled/react';
      export const styles = cssMap({
        primary: {
          '@layer utilities': {
            '&:hover': { color: 'red' },
          },
        },
      });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });

  it('cssMap: named @container + &:hover hashing parity', async () => {
    const code = `
      import { cssMap } from '@compiled/react';
      export const styles = cssMap({
        primary: {
          '@container card (width > 600px)': {
            '&:hover': { color: 'red' },
          },
        },
      });
    `;

    const babelOut = await babelTransform(code);
    const swcOut = await transformResultString(code, { extract: true, forceEnable: true });

    const b = extractHashes(babelOut);
    const s = extractHashes(swcOut);
    // eslint-disable-next-line no-console
    expect(b.classes).toEqual(s.classes);
    expect(b.keyframes).toEqual(s.keyframes);
  });
});
