import * as fs from 'fs';
import { dirname, join } from 'path';

import type { Resolver } from '@compiled/babel-plugin';

import type { CompiledVitePluginOptions } from './types';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const enhancedResolve = require('enhanced-resolve');

// Handle both ESM and CJS imports
const { CachedInputFileSystem, ResolverFactory } = enhancedResolve.CachedInputFileSystem
  ? enhancedResolve
  : enhancedResolve.default || enhancedResolve;

export function createDefaultResolver(config: CompiledVitePluginOptions): Resolver {
  const resolver = ResolverFactory.createResolver({
    fileSystem: new CachedInputFileSystem(fs, 4000),
    ...(config.extensions && {
      extensions: config.extensions,
    }),
    // This makes the resolver invoke the callback synchronously
    useSyncFileSystemCalls: true,
  });

  return {
    // The resolver needs to be synchronous, as babel plugins must be synchronous
    resolveSync(context: string, request: string) {
      return resolver.resolveSync({}, dirname(context), request) as string;
    },
  };
}

/**
 * Collects styles from distributed Compiled components.
 * Looks for .compiled.css files in node_modules that were generated by other packages.
 *
 * @param modulePaths - Paths to node_modules directories to scan
 * @returns Array of CSS rule strings
 */
export function collectDistributedStyles(modulePaths: string[]): string[] {
  const distributedStyles: string[] = [];

  for (const modulePath of modulePaths) {
    try {
      // Recursively find all .compiled.css files in node_modules
      const findCompiledCss = (dir: string): void => {
        if (!fs.existsSync(dir)) return;

        const entries = fs.readdirSync(dir, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = join(dir, entry.name);

          // Skip node_modules subdirectories to avoid infinite recursion
          if (entry.isDirectory() && entry.name !== 'node_modules') {
            findCompiledCss(fullPath);
          } else if (entry.isFile() && entry.name.endsWith('.compiled.css')) {
            try {
              const cssContent = fs.readFileSync(fullPath, 'utf-8');
              // Split by newlines and add each rule
              const rules = cssContent.split('\n').filter((rule) => rule.trim());
              distributedStyles.push(...rules);
            } catch (error) {
              // Silently skip files that can't be read
              console.warn(`[@compiled/vite-plugin] Could not read distributed CSS: ${fullPath}`);
            }
          }
        }
      };

      findCompiledCss(modulePath);
    } catch (error) {
      // Silently skip paths that don't exist or can't be read
    }
  }

  return distributedStyles;
}
